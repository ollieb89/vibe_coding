"""Output generator - Creates AGENTS.md and related files from discovery results."""

from datetime import datetime
from pathlib import Path

from agent_discovery.models import (
    AgentMatch,
    AgentType,
    Category,
    CodebaseProfile,
)


class OutputGenerator:
    """Generate AGENTS.md and related files from discovery results."""

    def __init__(self, vibe_tools_root: str | None = None):
        """Initialize the output generator.

        Args:
            vibe_tools_root: Path to vibe-tools for copying agent files
        """
        self.vibe_tools_root = Path(vibe_tools_root) if vibe_tools_root else None

    def generate_agents_md(
        self,
        matches: list[AgentMatch],
        profile: CodebaseProfile | None = None,
        project_name: str | None = None,
        include_setup: bool = True,
    ) -> str:
        """Generate AGENTS.md content from matched agents.

        Args:
            matches: List of matched agents from discovery
            profile: Optional codebase profile for context
            project_name: Project name for header
            include_setup: Include setup instructions

        Returns:
            Formatted AGENTS.md content
        """
        lines: list[str] = []

        # Header
        name = project_name or (Path(profile.path).name if profile else "Project")
        lines.append(f"# {name} - AI Agent Configuration")
        lines.append("")
        lines.append(
            f"Auto-generated by Agent Discovery System on {datetime.now().strftime('%Y-%m-%d')}"
        )
        lines.append("")

        # Project context (if profile available)
        if profile:
            lines.extend(self._generate_project_section(profile))

        # Setup instructions
        if include_setup:
            lines.extend(self._generate_setup_section())

        # Recommended agents
        lines.append("## Recommended Agents")
        lines.append("")

        # Group agents by category
        agents_by_category = self._group_by_category(matches)

        for category, category_matches in agents_by_category.items():
            lines.append(f"### {self._format_category(category)}")
            lines.append("")

            for match in category_matches:
                lines.extend(self._format_agent_entry(match))
                lines.append("")

        # Usage guide
        lines.extend(self._generate_usage_section(matches))

        # Footer
        lines.append("---")
        lines.append("")
        lines.append(
            "*Generated by [vibe-tools Agent Discovery System]" "(https://github.com/vibe-tools)*"
        )

        return "\n".join(lines)

    def generate_instructions_md(
        self,
        matches: list[AgentMatch],
        profile: CodebaseProfile | None = None,
    ) -> str:
        """Generate project-specific instructions based on matched agents.

        Args:
            matches: List of matched agents
            profile: Optional codebase profile

        Returns:
            Formatted instructions content
        """
        lines: list[str] = []

        lines.append("---")
        lines.append("description: 'Project-specific coding guidelines'")

        # Generate applyTo based on detected languages
        if profile and profile.languages:
            patterns = self._languages_to_glob(profile.languages)
            lines.append(f"applyTo: '{patterns}'")
        else:
            lines.append("applyTo: '**'")

        lines.append("---")
        lines.append("")
        lines.append("# Project Coding Guidelines")
        lines.append("")

        # Add detected technology context
        if profile:
            lines.append("## Technology Stack")
            lines.append("")
            if profile.languages:
                lines.append(f"- **Languages**: {', '.join(profile.languages)}")
            if profile.frameworks:
                lines.append(f"- **Frameworks**: {', '.join(profile.frameworks)}")
            if profile.patterns:
                lines.append(f"- **Patterns**: {', '.join(profile.patterns)}")
            lines.append("")

        # Extract key guidelines from matched agents
        lines.append("## Key Guidelines")
        lines.append("")

        # Group instruction-type agents
        instruction_agents = [m for m in matches if m.agent.agent_type == AgentType.INSTRUCTION]

        if instruction_agents:
            for match in instruction_agents[:5]:  # Top 5 instructions
                lines.append(f"### {match.agent.name}")
                lines.append("")
                lines.append(f"_{match.agent.description}_")
                lines.append("")
                if match.match_reasons:
                    lines.append(f"**Relevance**: {', '.join(match.match_reasons)}")
                    lines.append("")
        else:
            # Generate generic guidelines from other agent types
            lines.append("Apply best practices from the recommended agents:")
            lines.append("")
            for match in matches[:5]:
                desc = match.agent.description or "See agent for details"
                lines.append(f"- **{match.agent.name}**: {desc}")
            lines.append("")

        # Add common patterns section
        lines.extend(self._generate_common_patterns(profile))

        return "\n".join(lines)

    def generate_chatmode_md(
        self,
        matches: list[AgentMatch],
        profile: CodebaseProfile | None = None,
        chatmode_name: str = "project-assistant",
    ) -> str:
        """Generate a chatmode configuration for the project.

        Args:
            matches: List of matched agents
            profile: Optional codebase profile
            chatmode_name: Name for the chatmode

        Returns:
            Formatted chatmode content
        """
        lines: list[str] = []

        # Frontmatter
        lines.append("---")
        lines.append(f"name: {chatmode_name}")

        # Generate description based on profile
        if profile and profile.frameworks:
            desc = f"Project assistant for {', '.join(profile.frameworks[:2])} development"
        elif profile and profile.languages:
            desc = f"Project assistant for {', '.join(profile.languages[:2])} development"
        else:
            desc = "Intelligent project assistant with context-aware guidance"

        lines.append(f"description: '{desc}'")

        # Tags from profile
        tags = []
        if profile:
            tags.extend(profile.languages[:3])
            tags.extend(profile.frameworks[:2])
        if not tags:
            tags = ["assistant", "development"]
        lines.append(f"tags: [{', '.join(tags)}]")

        lines.append("---")
        lines.append("")

        # Title
        lines.append(f"# {chatmode_name.replace('-', ' ').title()}")
        lines.append("")

        # Context section
        lines.append("## Context")
        lines.append("")
        lines.append("You are an intelligent project assistant with deep knowledge of:")
        lines.append("")

        if profile:
            if profile.languages:
                lines.append(f"- **Languages**: {', '.join(profile.languages)}")
            if profile.frameworks:
                lines.append(f"- **Frameworks**: {', '.join(profile.frameworks)}")
            if profile.patterns:
                lines.append(f"- **Patterns**: {', '.join(profile.patterns)}")
        lines.append("")

        # Activation section
        lines.append("## Activation")
        lines.append("")
        lines.append("Use this mode when:")
        lines.append("")
        lines.append("- Working on this project's codebase")
        lines.append("- Need context-aware assistance")
        lines.append("- Want consistent guidance across sessions")
        lines.append("")

        # Included agents section
        lines.append("## Included Agents")
        lines.append("")

        for match in matches[:7]:  # Top 7 agents
            score_pct = int(match.score * 100)
            lines.append(f"- **{match.agent.name}** ({score_pct}% match)")
            if match.agent.description:
                lines.append(f"  - {match.agent.description[:100]}")
        lines.append("")

        # Instructions section
        lines.append("## Instructions")
        lines.append("")
        lines.append("When responding:")
        lines.append("")
        lines.append("1. Consider the project's technology stack and patterns")
        lines.append("2. Follow established conventions in the codebase")
        lines.append("3. Suggest improvements aligned with project architecture")
        lines.append("4. Reference relevant agents for specialized tasks")
        lines.append("")

        return "\n".join(lines)

    def generate_full_package(
        self,
        matches: list[AgentMatch],
        profile: CodebaseProfile | None = None,
        output_dir: str = ".",
        project_name: str | None = None,
    ) -> dict[str, str]:
        """Generate a complete package of configuration files.

        Args:
            matches: List of matched agents
            profile: Optional codebase profile
            output_dir: Directory to write files
            project_name: Project name for headers

        Returns:
            Dict mapping filename to content
        """
        files = {
            "AGENTS.md": self.generate_agents_md(matches, profile, project_name),
            ".github/instructions/project.instructions.md": self.generate_instructions_md(
                matches, profile
            ),
            ".github/chatmodes/project-assistant.chatmode.md": self.generate_chatmode_md(
                matches, profile
            ),
        }

        return files

    def write_files(
        self,
        files: dict[str, str],
        output_dir: str = ".",
        overwrite: bool = False,
    ) -> list[str]:
        """Write generated files to disk.

        Args:
            files: Dict mapping filename to content
            output_dir: Base directory for output
            overwrite: Whether to overwrite existing files

        Returns:
            List of written file paths
        """
        output_path = Path(output_dir)
        written = []

        for filename, content in files.items():
            filepath = output_path / filename

            # Check if exists
            if filepath.exists() and not overwrite:
                continue

            # Create parent directories
            filepath.parent.mkdir(parents=True, exist_ok=True)

            # Write file
            filepath.write_text(content, encoding="utf-8")
            written.append(str(filepath))

        return written

    # --- Helper Methods ---

    def _generate_project_section(self, profile: CodebaseProfile) -> list[str]:
        """Generate project context section."""
        lines = [
            "## Project Context",
            "",
        ]

        if profile.languages:
            lines.append(f"**Languages**: {', '.join(profile.languages)}")
        if profile.frameworks:
            lines.append(f"**Frameworks**: {', '.join(profile.frameworks)}")
        if profile.patterns:
            lines.append(f"**Patterns**: {', '.join(profile.patterns)}")

        features = []
        if profile.has_tests:
            features.append("Tests")
        if profile.has_ci:
            features.append("CI/CD")
        if profile.has_docker:
            features.append("Docker")

        if features:
            lines.append(f"**Features**: {', '.join(features)}")

        lines.append("")
        return lines

    def _generate_setup_section(self) -> list[str]:
        """Generate setup instructions section."""
        return [
            "## Setup",
            "",
            "To use these agents with GitHub Copilot:",
            "",
            "1. **Copy agent files** to `.github/agents/` in your repository",
            "2. **Copy instructions** to `.github/instructions/`",
            "3. **Reference agents** in your prompts with `@agent-name`",
            "",
            "Alternatively, use the vibe-tools CLI:",
            "",
            "```bash",
            "# Install vibe-tools agents globally",
            "vibe-tools install-agents",
            "",
            "# Or copy specific agents to current project",
            "vibe-tools copy-agent quality-engineer --to .github/agents/",
            "```",
            "",
        ]

    def _generate_usage_section(self, matches: list[AgentMatch]) -> list[str]:
        """Generate usage guide section."""
        lines = [
            "## Usage Guide",
            "",
            "### Quick Reference",
            "",
            "| Agent | Use Case | Invoke |",
            "|-------|----------|--------|",
        ]

        for match in matches[:10]:
            use_case = match.match_reasons[0] if match.match_reasons else "General assistance"
            invoke = f"`@{match.agent.name}`"
            lines.append(f"| {match.agent.name} | {use_case[:40]} | {invoke} |")

        lines.extend(
            [
                "",
                "### Example Prompts",
                "",
            ]
        )

        # Generate example prompts based on top agents
        if matches:
            top_agent = matches[0].agent
            lines.extend(
                [
                    f"**With {top_agent.name}:**",
                    "```",
                    f"@{top_agent.name} Review this code for potential issues",
                    "```",
                    "",
                ]
            )

        return lines

    def _group_by_category(self, matches: list[AgentMatch]) -> dict[Category, list[AgentMatch]]:
        """Group matches by category."""
        groups: dict[Category, list[AgentMatch]] = {}

        for match in matches:
            category = match.agent.category
            if category not in groups:
                groups[category] = []
            groups[category].append(match)

        return groups

    def _format_category(self, category: Category) -> str:
        """Format category for display."""
        names = {
            Category.FRONTEND: "ðŸŽ¨ Frontend",
            Category.BACKEND: "âš™ï¸ Backend",
            Category.FULLSTACK: "ðŸ”„ Full-Stack",
            Category.ARCHITECTURE: "ðŸ—ï¸ Architecture",
            Category.TESTING: "ðŸ§ª Testing & QA",
            Category.AI_ML: "ðŸ¤– AI/ML",
            Category.DEVOPS: "ðŸš€ DevOps",
            Category.SECURITY: "ðŸ”’ Security",
            Category.QUALITY: "âœ¨ Quality",
            Category.DATABASE: "ðŸ—„ï¸ Database",
            Category.PLANNING: "ðŸ“‹ Planning",
            Category.DOCUMENTATION: "ðŸ“ Documentation",
            Category.GENERAL: "ðŸ“¦ General",
        }
        return names.get(category, f"ðŸ“¦ {category.value.title()}")

    def _format_agent_entry(self, match: AgentMatch) -> list[str]:
        """Format a single agent entry."""
        lines = []
        agent = match.agent
        score_pct = int(match.score * 100)

        # Header with score
        lines.append(f"#### {agent.name} ({score_pct}% match)")
        lines.append("")

        # Description
        if agent.description:
            lines.append(f"_{agent.description}_")
            lines.append("")

        # Details
        details = []
        if agent.agent_type:
            details.append(f"**Type**: {agent.agent_type.value}")
        if agent.tech_stack:
            details.append(f"**Stack**: {', '.join(agent.tech_stack[:5])}")
        if agent.languages:
            details.append(f"**Languages**: {', '.join(agent.languages[:3])}")

        if details:
            lines.append(" | ".join(details))
            lines.append("")

        # Match reasons
        if match.match_reasons:
            lines.append(f"**Why recommended**: {', '.join(match.match_reasons)}")

        # Source
        if agent.source_path:
            source_name = Path(agent.source_path).name
            lines.append(f"**Source**: `{source_name}`")

        return lines

    def _generate_common_patterns(self, profile: CodebaseProfile | None) -> list[str]:
        """Generate common patterns section."""
        lines = [
            "## Common Patterns",
            "",
        ]

        if profile:
            if "typescript" in profile.languages or "javascript" in profile.languages:
                lines.extend(
                    [
                        "### TypeScript/JavaScript",
                        "",
                        "- Use async/await over raw promises",
                        "- Prefer const over let when possible",
                        "- Use TypeScript strict mode",
                        "",
                    ]
                )

            if "python" in profile.languages:
                lines.extend(
                    [
                        "### Python",
                        "",
                        "- Follow PEP 8 style guide",
                        "- Use type hints for function signatures",
                        "- Prefer pathlib over os.path",
                        "",
                    ]
                )

            if profile.has_tests:
                lines.extend(
                    [
                        "### Testing",
                        "",
                        "- Write tests for new features",
                        "- Maintain test coverage thresholds",
                        "- Use meaningful test names",
                        "",
                    ]
                )

        return lines

    def _languages_to_glob(self, languages: list[str]) -> str:
        """Convert language list to glob pattern."""
        ext_map = {
            "python": "*.py",
            "typescript": "*.ts,*.tsx",
            "javascript": "*.js,*.jsx",
            "java": "*.java",
            "go": "*.go",
            "rust": "*.rs",
            "ruby": "*.rb",
            "php": "*.php",
            "csharp": "*.cs",
        }

        patterns = []
        for lang in languages:
            lang_lower = lang.lower()
            if lang_lower in ext_map:
                patterns.append(ext_map[lang_lower])

        if patterns:
            return "**/{" + ",".join(patterns) + "}"
        return "**"
